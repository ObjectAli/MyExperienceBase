= Многопоточность (Multithreading)


Многопоточность (multithreading) — свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени. При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины.

Основные термины:
* Процесс - контейнер внутри ОС, содержащей информацию о действии - о потоках.
* Поток - объект, который выполняет инструкции над данными.

Архитектура, реализующая многопоточность АБСТРАКТНО включает в себя:

* Process Control Block - блок обработки процесса. Содержит:
** Process ID (PID) - идентификатор процесса
** Process State - состояние процесса
** Process counter - счётчик процессов
** Registers - набор регистров (?)
** Memory limits - лимит процессов
** List of open files - список открытых файлов

* Thread Control Block - блок обработки потока. Содержит:
** Parent process pointer - ссылка на родительский процесс
** Thread ID (TID) - идентификатор потока
** Thread State - состояние потока
** Program counter - счётчик программ
** Register Set - набор регистров (?)
** Stack Pointer - ссылка на ячейку памяти в Process Memory

* Process Memory - Стек ячеек памяти

== Процесс
Процесс - контейнер внутри ОС, содержащей информацию о действии - потоки (наименьшая единица обработки).

Процесс может содержать в себе:

* Исходный код
* Данные
* Файлы
* Доступные регистры
* Стек потока
* Потоки

Для решения задачи многопоточности процесс начинает приобретать следующий вид:

* Исходный код (Общий для всех потоков)
* Данные (Общие для всех потоков)
* Файлы (Общие для всех потоков)
* Регистры (Отдельно для каждого потока)
* Стек (Отдельно для каждого потока)
* Потоки

TIP: Процесс не может существовать без потоков, если есть процесс, значит в нём существует хотя бы один поток.

== Поток
Поток - наименьшая единица обработки, исполнение которой может быть назначено ядром ОС. При выполнении потока, процессором выделяется небольшой отрезок процессорного времени - Квант, когда это время истекает, процессор переключается на другой поток.

== Daemon потоки. Фоновый процессы
Daemon потоки позволяют описывать фоновые процессы, которые нужны только для обслуживания основных потоков выполнения и не могут существовать без них.

== Синхронизация
Синхронизация - это особый механизм многопоточности, который обеспечивает разным потоком доступ к общим ресурсам (например файлам).
Синхронизация является решением опасной ситуации, когда один поток может обрабатывать данные, которые УЖЕ обработаны другим потоком.
Для этого механизм синхронизации использует инструмент блокирования общего ресурса - lock. Чтобы другой поток не обращался к занятому ресурсу.

== Нюансы многопоточности
* Количество одновременно запущенных процессов "по честному" равно количеству процессоров (физических ядер).
* Если запустить задачу в два потока на одном процессоре, то на самом деле, ОС будет запускать их частями поочереди, заполняя освобождённые участки в стеке памяти. Процессор будет переключаться между потоками выполнения сотни раз в секунду.
* В каком порядке запускать потоки в рамках процесса решает планировщик потоков - механизм внутри ОС, программист это контролировать не может.

== Проблемы многопоточности

* Взаимная блокировка - Deadlock
* Состояние гонки - race condition

TIP: Не все Race condition потенциально производят Deadlock, однако, Deadlock происходят только в Race condition!

=== Взаимная блокировка (Deadlock)
DeadLock (Взаимная блокировка) - ситуация, при которой несколько потоков находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение.

=== LiveLock
LiveLock (Взаимная активность) - ситуация, когда потоки внешне как бы живут, но при этом не могут ничего сделать, т.к. условие, по которым они пытаются продолжить свою работу, не могут выполниться. По сути Livelock похож на deadlock, но только потоки не "зависают" на системном ожидании монитора, а что-то вечно делают.

=== Состояние гонки (Race condition)
Race condition (Состояние гонки) — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

Пример: Представим, что мы собираемся каждое действие совершать друг за другом - Открыл холодильник, достал яйца, зажёг плиту, разбил яйца в сковородку ...
Так как последовательностью выполнением потоков руководит механизм внутри ОС, то вероятно возникнет следующая ситуация при запуске каждого действия в рамках потока:
0 - Открыл холодильник
3 - Зажёг плиту
4 - Разбил яйца в сковородку
2 - Достал яйца
Последовательность очевидно нарушена!

=== Голодание (Starvation)
Starvation (Голодание) - ситуация, когда потоки не заблокированы, а им не хватает ресурсов на всех.

=== Почему создавать много потоков плохо?
Когда потоков много, процессору приходится переключаться между потоками. Этот процесс называется переключением контекста. Переключение между потоками — дорогостоящая операция, поскольку процессор должен сохранять локальные данные одного потока и загружать локальные данные другого потока. В конечном счете общая производительность пострадает, а не улучшится, если будет слишком много потоков.


== Источники
https://javarush.com/groups/posts/1878-mnogopotochnostjh-v-java
https://habr.com/ru/articles/693244/
=== Набор уроков
https://javarush.com/groups/posts/2047-threadom-java-ne-isportishjh--chastjh-i---potoki
https://javarush.com/groups/posts/2048-threadom-java-ne-isportishjh--chastjh-ii---sinkhronizacija
https://javarush.com/groups/posts/2060-threadom-java-ne-isportishjh--chastjh-iii---vzaimodeystvie