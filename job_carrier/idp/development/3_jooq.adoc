= JOOQ

JOOQ - это библиотека сопоставления баз данных на Java, реализующую шаблон активной записи.
Её цель состоит в том, чтобы быть как реляционной, так и объектно-ориентированной, предоставляя предметно-ориентированный язык для построения запросов из классов, сгенерированных из схемы базы данных.
JOOQ использует JDBC для вызова базовых SQL-запросов.
JOOQ генерирует код Java на основе базы данных и позволяет создавать безопасные SQL-запросы с помощью гибкого API.

== Назначение
JOOQ стоит использовать в двух случаях:
1. Если приходится часто работать с хранимыми процедурами
2. Если есть потребность в написании sql, которого нет "из коробки" в "jpa-фреймворках"

== Настройка JOOQ
Для подключения JOOQ к проекту необходимо выполнить шаги:
1. Подключить зависимости JOOQ
2. Описать миграцию БД
3. Настроить плагин JOOQ
4. Выполнить сборку проекта
5. Сгенерировать Java-классы на основе базы данных

=== Настройка генерации классов
В JOOQ можно настроить генерацию классов:

. Обновление всех классов при каждой сборке
. Генерация классов при вызове команды с хранением классов в репозитории

Классы можно генерировать на основе:

. JPA-сущностей
. SQL-скриптов (flyway, liquibase)
. На основе структур базы данных (таблицы, схемы и т.д.)

== Плюсы
* Обеспечивает абстракцию поверх JDBC, позволяет писать в объектно-ориентированном стиле.
* Позволяет писать сложные запросы, включающие псевдонимы, объединения, вложенные выделения, сложные соединения и др.
* Возможность контролировать запросы.
* Компиляция запросов на уровне Java-кода
* При изменении структуры базы данных невозможно забыть обновить код (jooqGenerate)
* Механизм интеграции SQL в Java-код
* Типобезопасный SQL - проверка соответствия типов данных колонок таблиц и полей Java-объектов.
* Поддержка scala, groovy, kotlin
* Возможность Multi-Tenancy - JOOQ позволяет легко конфигурировать среду, позволяя переписывать сгенерированные имена схема и таблиц SQL (берёт на себя проблему с инфраструктурой Java/SQL).
* Берёт на себя преобразование SQL в соответствии с БД.

== Минусы
* Так как в JOOQ используются Record классы, который реализуют один из интерфейсов Record1 ... Record22 (по количеству колонок), то ограничением будет являться таблица, содержащая не больше 22 колонок.
* В отличие от Hibernate, при работе с таблицами, имеющими связь один-ко-многим и др., нужно вручную прописывать заполнение полей, содержащих id связи. Поэтому необходимо писать маппер.
* Код выглядит более громоздким

== JPA
Java Persistence API (JPA) - спецификация API Java EE, которая предоставляет возможность сохранять в удобном виде Java-объекты в базе данных.
Hibernate -> JPA -> ORM
JOOQ -> JDBC -> SQL

== Выбор между JOOQ и Hibernate
Выбор между JOOQ и Hibernate - это, в основе, выбор между ORM и SQL
Вопросы помогающие выбрать:

. Будет ли модель данных определять дизайн приложения или дизайн приложения будет определять модели данных?
.. Если модель данных определяет дизайн приложения - тогда выбор за JOOQ
.. Если дизайн приложения определяет модель данных - тогда выбор за Hibernate
. Будете ли вы заниматься в основном сложным чтением и простым письмом, или вы будете заниматься сложным письмом?
.. Если, подразумевается использование базовые CRUD-сервисов или сложное письмо - тогда выбор за Hibernate
.. Если, подразумевается использование "сложного чтения", объединение таблиц, агрегирование, массовое чтение или запись - тогда выбор за JOOQ

В 70% случаев для базовых сервисов достаточно использовать Hibernate, в остальных 30% особых случаев, лучше использовать JOOQ.

== Итог
Большинство проектов действительно на 90% читают и на 10% записывают, причем запись часто не является сложной (2-3 таблицы, измененные в транзакции). Это означает, что в большинстве случаев сложность, решаемая кэшами первого и второго уровня Hibernate/JPA, не нужна. Люди часто неправильно понимают эти функции и просто отключают кэширование, постоянно сбрасывая кэш Hibernate на сервер и, таким образом, неправильно используя Hibernate.

Если, однако, вы не определились с двумя вышеуказанными осями решения, вы можете пойти средним путем и использовать jOOQ только для отчетности, пакетной обработки и т. Д.
И использовать Hibernate для вашего CRUD - в стиле CQRS. Есть также довольно много пользователей jOOQ, которые выбрали этот путь.

<https://blog.jooq.org/jooq-vs-hibernate-when-to-choose-which/>

== Основные особенности
=== Основные объекты при работе с JOOQ
DSLContext и DSL - классы, являющиеся основной точкой входа для клиентского кода для доступа к классам и функциям JOOQ. На них завязана вся работа приложения с доступом к базе данных.
Все методы DSL являются статическими, что особенно удобно для вызова функций класса DSL.
DSLContext = интерфейс, описывающий sql операторы (select, where и другие).
DSL - класс, содержащий статические методы, описывающие SQL функции (DSL.max(), DSL.min() и другие).

=== Типы обработки запросов
Все типы обработки запросов делятся на те, которые что-то возвращают (fetch()) и что-то выполняют (execute())

=== Принудительные типы JOOQ
В JOOQ есть возможность вручную переопределять типы данных столбцов, атрибутов и параметров тремя способами:

* Перезаписав их в какой-либо другой тип данных, с помощью функции перезаписи типов данных.
** Через конструкцию forcedTypes - forcedType (и дальше, используя свойства для отбора, типа includeExpression и др.).
* Сопоставляя их с каким-либо типом пользователя, с помощью функции конвертера типов данных и пользовательского org.jooq.Converter
** Это когда внутри forcedType используется свойство converter (converter = 'com.example.IntegerToYearConverter'), которое будет дёргать класс, ответственный за конвертацию данных.
* Сопоставляя их с каким-либо типом пользователя, с помощью функции привязки типа данных и пользовательской привязки org.jooq.Binding
** Реализуя интерфейс Binding, можно создать свой класс, описывающий авторский тип данных.