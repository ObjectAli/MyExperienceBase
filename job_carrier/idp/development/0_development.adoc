== Неизменяемые классы:
Неизменяемым называется любой класс, в котором состояние объекта не меняется после создания экземпляра класса.

* Примеры неизменяемых классов: String, все классы-оболочки* и enum.
* Неизменяемые классы всегда потокобезопасны.

Обертка* — это специальный класс, который хранит внутри себя значение примитива.

Как создать неизменяемый класс:

. Убедитесь, что класс нельзя переопределить, — объявите класс final.
(прим. ред. Класс, объявленный с модификатором final, не может иметь подклассов и исключает наследование.)
. Все поля должны быть закрытыми.
. Не добавляйте методов, которые могут изменять состояние объекта. Никаких сеттеров.
. Используйте клонирование или защитное копирование.

С Immutable классом всегда легче работать. Его состояние не поменяется, значит обращаться к нему в многопоточной среде можно без дополнительной синхронизации. Функции, зависящие только от состояния экземпляра будут возвращать один и тот же результат от вызова к вызову – это облегчает например реализацию hashCode

== Интерфейсы. Методы Интерфейса
Интерфейс — это разновидность класса. Сильно урезанная, если можно так сказать. У интерфейса, в отличие от класса, не может быть своих переменных (кроме статических). Также нельзя создавать объекты типа Интерфейс

* У интерфейсов все методы public. (С Java 9 появились и private)
* Все методы интерфейсов абстрактные (abstract писать не нужно).
* Интерфейс может наследоваться только от интерфейсов (Множественное наследование, если интерфейсов родителей несколько).
* Класс может наследоваться только от одного класса.
* Класс может наследоваться от интерфейса(-сов) (implements как раз для этого и предназначен).
* В интерфейсах можно объявлять ТОЛЬКО СТАТИЧЕСКИЕ переменные.
* Методы с реализацией "по умолчанию" - default (начиная с Java 8).
* Статичные методы (начиная с Java 8).
* Статичные константы (по умолчанию они имеют модификатор доступа public static final)

== Lombok
Это основанная на аннотациях библиотека Java, позволяющая сократить шаблонный код.
Проект Lombok включается прямо в процесс сборки. Затем Lombok автоматически сгенерирует для Java байт-код, который вставляет в файлы .class, необходимые для реализации желаемого поведения, в зависимости от используемых вами аннотаций.

== Аннотации Lombok
* @Getter
* @Setter
* @AllArgsConstructor, @NoArgsConstructor, @RequiredArgsConstructor (@NonNull и неинициализированные final поля)
* @ToString
* @EqualsAndHashCode
* @NonNull
* @Data (включает в себя @ToString, @EqualsAndHashCode, @Getter, @Setter и @RequiredArgsConstructor)
* @Value (для final классов)
* @Cleanup (позволяет гарантировать, что заданный ресурс будет автоматически очищаться перед тем, как покинет актуальную область видимости)
* @Synchronized (действует примерно так же, как synchronized, но защелкивается на особом приватном поле под названием $lock)
* @SneakyThrows (позволяет бесшумно выбрасывать проверяемые исключения, не объявляя их явно в условии throws метода)
* @Builder
* @Log
* @With (добавляет методы для каждого поля, которые делают клон объекта с одним измененным полем)
* @FieldDefaults (задаёт уровень видимости полей и методов: public, private, protected)

== Отключение Lombok
На случай если потребуется отключить Lombok, у него есть инструмент delombok. Он обеспечивает автоматическую генерацию исходного кода Java, содержащего в байт-коде ровно те же возможности, которые внедрялись бы при помощи Lombok. Таким образом, база кода, аннотированная Lombok, просто заменяется стандартной базой кода на Java, без Lombok. После этого весь проект больше вообще не будет зависеть от Lombok.


== StreamApi

Класс Stream был создан для того, чтобы можно было легко конструировать цепочки потоков данных.
Stream - это инструмент для поддержки распараллеливания вычислений в потоках. Предоставляет возможность обрабатывать одну или несколько операций, которые могут выполняться последовательно или параллельно (метод parallel или Collection.parallelStream).
Внутри потока данных, данные вообще не меняются. Цепочка промежуточных методов – это хитрый (декларативный) способ указания некой последовательности обработки данных, которая начнет выполняться после вызова терминального (конечного) метода.

Разница между коллекцией и потоками в java в том, что коллекции позволяют работать с отдельными элементами (добавлять элементы, удалять, вставлять в середину), тогда как потоки этого не позволяют, но вместо этого позволяют выполнять функции над данными как одним целом.

=== Методы
Все методы потоков (Stream) делятся на два типа:

. Intermediate (промежуточные) - возвращают объект, который имплементируют объект типа Stream.
[source, java]
----
Stream<R> map();
----

. Terminal (конечные) - возвращают значение, тип которого отличен от типа Stream.
[source, java]
----
long count();
----