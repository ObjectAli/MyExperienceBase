= Многопоточность в проекте SMC

Для просмотра запущенных потоков стоит выполнить команду в терминале 'jps', а затем найти PID приложения с названием 'Application' (например)
Далее выполнить команду 'jvisualvm --openpid <PID>'. В появившемся окне можно выбрать вкладку Threads.

Ключевые классы:

* Executor.class - интерфейс для execute (выполнения) некой задачи в потоке, когда реализация создания скрыта.
* ExecutorService.class - интерфейс-наследник от Executor.class, который имеет набор возможностей по управлению ходом выполнения.
* Executors - Фабрика, для создания ExecuteService.
* ScheduledExecutorService - интерфейс для запуска задач по расписанию.

* ThreadLocal.class

== ExecutorService
Пример использования ExecutorService.class можно увидеть в классе ManagedServiceComponentCoreService.class

=== метод execute()
Позволяет отправить задачу на выполнение

=== метод submit()
Позволяет отправить задачу на выполнение и возвращает объект интерфейса Future.class, что даёт возможность контролировать поток.

== Создание потоков
=== ThreadFactory
С помощью фабрики создания потоков ThreadFactory можно делать разные настройки создаваемым потокам, например, – выставить приоритеты, использовать подклассы потоков.

=== Executors
==== метод newSingleThreadExecutor
Создаёт ExecutorService с пулом, включающим в себя единственный поток.
Принцип работы:

* Сервис выполняет за раз только одну задачу.
* Если мы отправляем N задач на исполнение, все N задач одна за другой будет выполняться одним потоком.
* Если поток будет прерван, то создастся новый поток для выполнения остальных задач.

=== ThreadLocal
ThreadLocal — это удобный инструмент для обеспечения изоляции данных в многопоточной среде. Однако стоит помнить, что неправильное использование ThreadLocal может привести к утечке памяти, поэтому его следует использовать с осторожностью.
Используется в ситуациях, когда есть общий ресурс, к которому обращаются разные потоки. Если данные этого ресурса изменяются в одном потоке, это может повлиять на работу других потоков, что может привести к непредсказуемым результатам.

=== Lock
Lock — интерфейс из lock framework, предоставляющий гибкий подход по ограничению доступа к ресурсам/блокам по сравнению с synchronized. При использовании нескольких локов порядок их освобождения может быть произвольный, плюс его также можно настроить. Еще имеется возможность обработать ситуацию, когда лок уже захвачен.

=== ReentrantLock
ReentrantLock — одна из реализаций интерфейса Lock. Он позволяет одному и тому же потоку вызывать метод lock, даже если он его вызывал ранее, без освобождения блокировки.
У класса ReentrantLock, кроме методов интерфейса Lock, есть фабричный метод newCondition(). Этот метод возвращает объект Condition, который позволяет добавить текущий поток в wait set данного объекта Condition.

== Примеры
=== Класс DynamicPropertySource
. Создание пула потоков, состоящего из одного элемента.
//"private final ExecutorService listenerExecutor = Executors.newSingleThreadExecutor();"
. Вызов метода execute() - отправка блока кода на исполнение, при условии, что "слушатели" из коллекции changeListeners = new ConcurrentHashMap<>() ещё есть.

=== Класс ManagedServiceComponentCoreService
. Создание локального потока, содержащем объекты типа ManagedServiceExecutionContext
//private static ThreadLocal<ManagedServiceExecutionContext> contexts = new ThreadLocal<>();
. Объявление ExecutorService
//private ExecutorService executorService;
. При выполнении метода init(), происходит инициализация переменной типа ExecutorService пулом из 10 потоков
//executorService = Executors.newFixedThreadPool(10);
. Если сервис "s" готов к запуску, то (см. строку 1)
.. происходит создание контейнера для запуска сервиса по расписанию (см. строку 2)
.. происходит запуск задачи, с созданием переменной, содержащей информацию о потоке исполнения (см. строку 3)
.. присвоение сервису атрибута, содержащем информацию о потоке исполнения
//1) if( s.isReadyToStartWithFixedDelay() ) {
//2)    SchedulableTaskContainer st = new SchedulableTaskContainer( this, s );
//3)    Future<SchedulableTaskContainer> f = executorService.submit( st, st );
//4)    s.setFuture( f ); }