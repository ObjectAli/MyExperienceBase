== Многопоточность в Java (Java Multithreading)
Основу работы с потока в Java составляют интерфейс Runnable (@FunctionalInterface public interface Runnable) и класс Thread (public class Thread extends Object implements Runnable).

Изначально программа состоит из главного потока - Main Thread. Главный поток запускает метод main().
По ходу выполнения программы могут быть запущены дочерние потоки.
Программа (написанная на Java) завершится, как только завершится последний её поток не являющийся демоном (метод main() при этом может быть уже давным-давно завершен).

=== Способы создания и запуска нового потока в Java
* Реализовать интерфейс Runnable
* Унаследовать класс Thread

В обоих случаях понадобится переопределить метод void run().
Runnable – функциональный интерфейс, что позволяет использовать лямбда выражение.
В Java экземпляры класса Thread.class могут объединяться в группы (ThreadGroup.class) для формирования структуры и иерархии.

=== Особенности выбора
* Наследование класса Thread целесообразно применять когда нужно дополнить функциональность самого класса Thread.
* Использование интерфейса Runnable – когда просто нужно одновременно выполнить несколько задач и не требуется вносить изменений в сам механизм многопоточности.

== Особенности Java Multithreading
=== Особенности запуска потоков
* Для запуска НОВЫХ потоков нужно вызывать метод start(), а не run().
* Метод start() заставляет этот поток начать выполнение.
* Виртуальная машина Java сама вызывает метод запуска run() этого потока.
* Прямой вызов метода run() не имеет отношения к многопоточности – в этом случае программа будет выполнена в главном потоке Main Thread.
* В каком порядке запускать новые потоки решает Планировщик потоков – часть JVM, которая решает какой поток должен выполнится в каждый конкретный момент времени и какой поток нужно приостановить.
* Если поток был запущен и завершился – повторно запустить его не получится.

=== Особенности выполнения потоков
* Последовательность выполнения потоков контролировать нельзя.

=== Особенности остановки потоков
* Поток нельзя остановить – он может остановиться только сам. Но можно явно указать, что потоку следует остановиться.
* Класс Thread содержит скрытое булево поле – флаг прерывания. Установить флаг можно вызвав метод потока interrupt(). Это укажет, что поток следует прервать, но не прервет его тут же.

=== Особенности завершения потоков
* Main Thread завершается вместе с выходом из метода main(), а Дочерний поток – завершая выполнение метода run().


=== Особенности жизненного цикла потоков
Существует 4 состояния жизненного цикла объекта:

* Состояние New
** Когда создается новый экземпляр объекта класса Thread, но метод start() не вызывался.
* Состояние Runnable
** Когда для созданного нового объекта Thread был вызван метод start(). Такой поток либо ожидает, что планировщик заберет его для выполнения, либо уже запущен.
* Состояние Non-Runnable (Blocked , Timed-Waiting)
** Когда поток временно неактивен, то есть объект класса Thread существует, но не выбран планировщиком для выполнения.
* Состояние Terminated
** Когда поток завершает выполнение своего метода run(), он переходит в состояние terminated (завершен). На этом этапе выполнение потока завершается.


=== Приоритет потоков
Для контроля важности и очерёдности работы разных потоков существует приоритет. Он является одним из ключевых факторов выбора системой потока для выполнения.

* Приоритет может иметь числовое значение от 1 до 10.
* По умолчанию главному потоку выставляется средний приоритет – 5

=== Переключение потоков
==== Присоединение к потоку
Метод - join().
Цель: Остановка заданного потока в пользу другого.
Суть: Свое выполнение начнёт выбранный поток. Выполнение текущего потока будет приостановлено.

==== Усыпление потока
Метод - sleep().
Цель метода – усыпить поток на некоторое время.
Суть: Часто используется в дочерних потоках, когда нужно делать какое-то действие постоянно, но не слишком часто. Поток в состоянии сна можно прервать.
После того как поток просыпается, он переходит в состояние runnable. Однако это не значит, что Планировщик потоков запустит сразу и именно его.

==== Пропуск очередности (хода)
Метод - Thread.yield() (аналог Thread.sleep())
Цель – усыпить поток на некоторое время.
Позволяет досрочно завершить квант времени текущего потока: переключает процессор на следующий поток.

==== Ожидание потока
Метод - wait().
Суть: Выполняется метод wait на объекте, на мониторе которого мы хотим выполнить ожидание.

==== Парковка потока
Метод - LockSupport.park() или ReentrantLock.lock() (Локи в Java построены так же на LockSupport)
Суть: Вызов метода park возвращается немедленно, если permit доступен, занимая этот самый permit в процессе вызова. Иначе он блокируется.


=== Daemon потоки. Фоновые процессы
Для работы с Daemon потоками у класса Thread существуют методы:

* setDaemon()
* isDaemon()

JVM прекращает работу, как только все не Daemon потоки завершаются.

=== Использование памяти
* Чем больше потоков создается – тем больше памяти используется.
* Во многих системах может быть ограничение на количество потоков.
* Даже если такого ограничения нет, в любом случае имеется естественное ограничение в виде максимальной скорости процессора.
* Для каждого потока создается свой собственный стек в памяти. Туда помещаются все локальные переменные и ряд других данных, связанных с выполнением потока.

=== Синхронизация потоков в Java (Synchronized)
Механизм синхронизации обеспечивает последовательный доступ к ресурсам. Выполнение программы не будет продолжено, пока заблокированный ресурс не освободится.
Для блокировки ресурса используется ключевое слово synchronized. Синхронизированным может быть как отдельный метод, так и блок кода.

[source, java]
----
public class Test {
    public synchronized void test() {}
}
----

* final поля класса инициализируются в его конструкторе – соответственно значение final полей будет видно всем потокам без синхронизации.
* static метод – в этом случае синхронизация будет осуществляться по классу, где этот метод объявлен.
* Если у объекта один синхронизированный метод статический, а другой синхронизированный метод не статический – они могут одновременно выполняться т.к. монитор (блокировка) для первого – класс, а для второго – объект. (!)
* Недостатком использования synchronized является вынужденное ожидание другими потоками освобождения нужного объекта или метода - bottle neck (узкое место).

=== Семафоры (Monitor. Mutex. Semaphore)
==== Семафор (Semaphore)
Определение: Семафор — это средство синхронизации доступа к ресурсу для ограничения количество потоков, которые могут войти в заданный участок кода.
Свойство: Семафор использует СЧЁТЧИК потоков, который указывает, сколько потоков ОДНОВРЕМЕННО могут получать доступ к общему ресурсу.

==== Мьютекс (Mutex)
Определение: Мьютекс — поле для синхронизации потоков. Есть у каждого объекта в Java.
Свойство: Это простейший Семафор, который может находиться в одном из двух состояний: true или false.

==== Монитор (Monitor)
Определение: Монитор — это дополнительная надстройка над Мьютексом.
Свойство: Блокирует объект именно монитор.

==== Принципы работы
* Когда один поток заходит внутрь synchronized блока кода, JVM тут же блокирует Mьютекс синхронизированного объекта.
* Больше ни один поток не сможет зайти в этот блок, пока текущий поток его не покинет.
* Как только первый поток выйдет из блока synchronized, Mьютекс автоматически разблокируется и будет свободен для захвата следующим потоком.
* Когда Mьютекс занят – новый поток будет ждать, пока он не освободится.


=== Модификатор volatile
==== Предпосылки возникновения
При взаимодействии с переменной каждый поток хранит ее значение в своем стеке.
Может возникнуть ситуация, что один поток изменит значение общей переменной, а второй поток будет продолжать работать с ее старым значением из своего кэша.
Также, в отличие от других примитивных типов данных, операции чтения и записи long и double не являются атомарными из-за их большого размера (64 бита).
Эти две проблемы решает модификатор volatile.
Ключевое слово volatile применимо к переменным. volatile в Java гарантирует, что значение переменной volatile всегда будет считываться из основной памяти, а не из локального кэша Thread.

==== Принцип работы
Операции чтения и записи volatile переменной являются атомарными.
Переменная не будет помещаться в кэш: результат записи значения в volatile переменную одним потоком будет виден всем другим потокам, которые используют эту переменную для чтения.

[source, java]
----
public class Example {
    public volatile long x;
    public volatile double y;
}
----


===  Интерфейс Callable
Назначение: Получение результата работы потока (начиная с Java 5).

* Callable очень похож на интерфейс Runnable, НО в отличие от Runnable объявляет метод call(), который возвращает результат работы потока.
* Использует дженерики для указания типа возвращаемого объекта.
* Кроме того метод call() бросает Exception.

Отличия:
* Runnable изначально был разработан для длительного параллельного выполнения.
* Callable предназначен для одноразовых задач, которые возвращают один результат.

=== Интерфейс Future
Назначение: Описывание API для работы с задачами, результат которых мы планируем получить в будущем: методы получения результата, методы проверки статуса.

Для Future нас интересует его реализация java.util.concurrent.FutureTask. То есть это Task, который будет выполнен во Future.
Чем эта реализация ещё интересна, так это тем, что она реализует и Runnable. Можно считать это своего рода адаптером старой модели работы с задачами в потоках и новой модели (новой в том смысле, что она появилась в java 1.5).

TIP: Во время получения результат методом get() выполнение становится синхронным - использование механизма LockSupport (park).

=== Класс CompletableFuture
Назначение: Класс CompletableFuture - новый класс из Java 8 для асинхронной работы.

* Дает возможность комбинировать шаги обработки результата, соединяя их в цепочку.
* Как и Future, использует дженерики для указания типа возвращаемого объекта.
* Если значение возвращать не нужно, а нужно только провести промежуточную операцию над результатом – существуют методы thenRun() и thenAccept()


=== Concurrency. Неблокирующая синхронизация
==== Предпосылки возникновения
Когда обрабатывают крупный массив данных на многоядерном процессоре, обычные структуры данных можно оградить мьютексом только целиком, и если потоки постоянно к ним обращаются, работа становится почти что последовательной.
Неблокирующие алгоритмы гарантируют, что такие остановки одного из потоков не приведут к простою остальных.

==== Назначение
Неблокирующая синхронизация позволяет полностью избавиться от взаимных блокировок. Разделение доступа между потоками идёт за счёт атомарных операций и разработанных под конкретную задачу механизмов блокировки.

Пакет java.util.concurrent включает в себя несколько небольших стандартизированных расширяемых фреймворков, а также некоторые классы, которые обеспечивают полезную функциональность и в остальном утомительны или сложны в реализации.
Классы и интерфейсы пакета java.util.concurrent объединены в несколько групп по функциональному признаку:


* Collections – набор более эффективно работающих в многопоточной среде коллекций нежели стандартные универсальные коллекции из java.util пакета
* Synchronizers – объекты синхронизации, позволяющие управлять и/или ограничивать работу нескольких потоков.
* Atomic – набор атомарных классов, позволяющих использовать принцип действия механизма оптимистической блокировки для выполнения атомарных операций.
* Queues – объекты создания блокирующих и неблокирующих очередей с поддержкой многопоточности.
* Locks – механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll
* Executors – механизмы создания пулов потоков и планирования работы асинхронных задач

=== Атомарные классы. Atomic
TIP: Операция называется атомарной, когда ее можно безопасно выполнить при параллельных вычислениях в нескольких потоках, не используя при этом блокировок.

Атомарные классы работают по принципу ОПТИМИСТИЧЕСКОГО ПОДХОДА

==== Пессимистический подход
Суть в том, что разрешается ТОЛЬКО ОДНОМУ потоку выполнять определённый код, связанный с изменением значения некоторой общей переменной.
Так работает БЛОКИРОВКА.

==== Оптимистический подход
Суть в том, что если поток обнаруживает, что значение переменной изменилось другим потоком, то он повторяет операцию снова, но уже с новым значением переменной.
В этом случае блокировки НЕ ПРОИСХОДИТ.
Так работают Атомарные классы.

==== Принципы работы
* Атомарная операция либо выполняется целиком, либо не выполняется вовсе.
* Атомарные классы ГАРАНТИРУЕТ, что определенные операции будут выполняться ПОТОКОБЕЗОПАСНО  (например операции инкремента и декремента, обновления и добавления значения (add)).
* Когда требуется примитивный тип, выполняющий операции инкремента и декремента, гораздо проще выбрать его среди атомарных классов в пакете java.util.concurrent.atomic, чем писать synchronized блок самому.
* Внутри атомарные классы используют сравнение с обменом – атомарную инструкцию, которая работает гораздо быстрее, чем синхронизация с помощью блокировок. Поэтому, если просто нужно изменять одну переменную с помощью нескольких потоков, лучше выбирать атомарные классы.
* Сравнение с обменом  – атомарная инструкция, сравнивающая значение в памяти с одним из аргументов, и в случае успеха записывающая второй аргумент в память.

== Особенности и проблемы
=== @Deprecated метод Thread.stop()
Метод для прерывания потока объявили Deprecated, так как при вызове данного метода поток просто "убивался", что было очень непредсказуемо и влекло за собой проблемы. Разработчик не могу знать, когда поток будет остановлен.
Поэтому решили не убивать поток, а уведомлять планировщик о том, что потоку следует прерваться, когда и как - решит механизм внутри ОС.