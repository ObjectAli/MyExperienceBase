= Spring

Spring упрощает создание корпоративных приложений с использованием Java. Он предоставляет все необходимое для использования языка Java в корпоративной среде, в том числе поддержку Groovy и Kotlin в качестве альтернативных языков в JVM, а также предлагает гибкость для создания множества видов архитектур в зависимости от потребностей приложения.

Java-аннотация - это специальная форма синтаксических метаданных, которая может быть добавлена в исходный код. Аннотации используются для анализа кода, компиляции или выполнения. Аннотации могут применяться к пакетам, классам, методам, переменным и параметрам.

== Inversion of control (IoC)
Inversion of control - это принцип, при котором управление потоком программы или созданием объектов переносится от пользовательского кода к фреймворку или контейнеру.
Это позволяет пользовательскому коду быть более гибким и абстрактным, а также избавляет его от необходимости знать детали реализации фреймворка.
Коротко: При использовании IoC кодом будет управлять фреймворк, а не программист.

Основные пакеты:

* org.springframework.beans
* org.springframework.context

Ключевые классы:

* BeanFactory - интерфейс, который предоставляет расширенный механизм конфигурации, способный управлять объектами любого типа (обеспечивает основу конфигурации и базовый функционал).
* ApplicationContext - подинтерфейс BeanFactory, который добавляет более специфичную корпоративную функциональность. ApplicationContext представляет IoC-контейнер Spring и отвечает за создание экземпляра, настройку и компонование бинов. Контейнер получает инструкции о том, какие объекты создавать, конфигурировать и компоновать путем считывания конфигурационных метаданных. (?)

== Bean (Бин)
Бин (bean) - это объект, который создается, компонуется и управляется IoC-контейнером Spring.

== Dependency Injection (DI)
DI (Dependency Injection) - это один из способов реализации IoC, при котором зависимости объектов передаются через конструктор, сеттер или поле, а не создаются внутри объектов. Можно использовать аннотации @Autowired или @Inject для внедрения зависимостей в бины/

Способы описания зависимости классов:

* Через конструктор (лучше для обязательных зависимостей)
* Через сеттер (для НЕ обязательных зависимостей))
* Через через атрибут

== Аннотации Spring
=== Аннотация @Autowired
Позволяет не внедрять зав-ти вручную (через XML), а делегировать Spring-у задачу внедрения зав-тей. Spring сам ищет подходящий бин.

Принцип работы @Autowired:

. Spring сканирует все классы с аннотацией @Component и создаёт бины для этих классов.
. Spring сканирует все созданные бины и проверяет, подходит ли хотя бы один бин в качестве за-ти там, где мы указали аннотацию @Autowired.
.. Если находится один подходящий бин, он внедряется в качестве зав-ти.
.. Если не находится ни одного бина - ошибка.
.. Если находится несколько подходящих бинов - неоднозначность.

Можно указывать на конструктор, сеттер и поле.

Вместо @Autowired может быть использована аннотация @Inject.

== Аннотация @Inject
Аннотация @Inject работает по похожему принципу, что и @Autowired. Разница заключается в том, что @Autowired является частью Spring Framework, а @Inject  является частью стандарта JSR-330. Также есть ещё отличие в том, что в случае, если несколько бинов имеют один и тот же тип, будет выброшено исключение, при использовании, аннотации @Inject, а если бин не найден, @Inject не приводит к ошибке при старте приложения, вместо этого значение будет null.

TIP: При выборе между @Autowired и @Inject стоит понимать, что аннотация @Autowired более популярна, так как является частью Spring Framework. Выбирать в пользу аннотации @Autowired стоит в случае, если необходимо, чтобы приложение запустилось, даже если некоторые зависимости отсутствуют.

TIP: Аннотации @Autowired, @Inject, @Value и @Resource обрабатываются реализациями BeanPostProcessor в Spring. Это означает, что невозможно применять эти аннотации внутри ваших собственных типов BeanPostProcessor или BeanFactoryPostProcessor (если таковые имеются). Эти типы должны быть "связаны" явным образом с помощью XML или метода @Bean в Spring.

== Аннотация @Value
Аннотация @Value позволяет внедрить значение атрибуты из файла конфигурации. Часто используется вместе с аннотацией  @PropertySource("имя пакета").

[source, java]
----
class Config {
    @Value("${bean.name}") String beanName;
}
----

=== Аннотация @Qualifier
Позволяет разрешать ситуации наличия бинов с одинаковым именем (id)

Можно указывать на конструктор (рядом с арг-ми конструктора), сеттер и поле.

Пример: Есть интерфейс Music.class и есть два класса реализующих его: ClassicalMusic.class и RockMusic.class.
Также, в другом классе, есть внедрение зав-ти по полю: @Autowired private Music music.
Далее происходит вызов метода класса, реализующего интерфейс. Проблема: Непонятно вызов метода какого из классов должен произойти ClassicalMusic или RockMusic.
Проблема и решение представлены ниже:

[source, java]
----
@Component
public class MusicPlayer {
    @Autowired
    //@Qualifier("classicalMusic") Для решение проблемы, описанной ниже, нужно добавить аннотацию @Qualifier с уточнением какой класс использовать
    private Music music;

    public String playMusic() {
        return music.play(); //Непонятно вызов метода какого из классов должен произойти ClassicalMusic или RockMusic
    }
}
----

=== Аннотация @Component и её производные
Аннотация @Component - это аннотация, которая позволяет Spring автоматически обнаруживать наши пользовательские компоненты.
Другими словами, без необходимости писать какой-либо явный код, Spring выполняет следующие действия сам:

* Сканирует приложение на наличие классов с аннотациями @Component
* Создаёт их экземпляры и внедряет в них все указанные зависимости
* Вводит их везде, где это необходимо

Может быть использована только на класс.
Однако большинство разработчиков предпочитают использовать более специализированные аннотации стереотипов для выполнения этой функции(@Service, @Controller, @Repository).

==== Производные аннотации от @Component
Spring предоставила несколько специализированных аннотаций к стереотипам: @Controller, @Service и @Repository. Все они выполняют ту же функцию, что и @Component.
Можно посмотреть сами классы аннотаций и увидеть, что все они в себе содержат аннотацию @Component. Данные аннотации именно смысловые.

* @Controller -  служит специализацией @Component, позволяя автоматически определять классы реализации с помощью сканирования classpath. @Controller аннотация указывает контейнеру Spring IOC рассматривать этот класс как контроллер Spring MVC. Используется в сочетании с аннотацией @RequestMapping на методы. Нельзя заменить на другую.
* @Service - описывает уровень бизнес-логики. Взаимозаменима с другими.
* @Repository - описывает, что класс содержит в себе CRUD-операции (уровень DAO). Взаимозаменима с другими.

=== Аннотация @Configuration
Аннотация @Configuration указывает, что класс объявляет один или несколько @Bean методов и могут быть обработаны контейнером Spring для генерации определений bean-компонентов и Запросы на обслуживание этих компонентов во время выполнения.

@Configuration Классы могут загружаться не только с помощью компонента сканирование, но также могут сами настроить сканирование компонентов с помощью Аннотация @ComponentScan("пакет").

Также класс конфигурации бинов можно зарегистрировать, с помощью класса AnnotationConfigApplicationContext метод register

TIP: Аннотация @Import позволяет импортировать конфигурацию из другого класса, помеченного аннотацией @Configuration

=== Аннотация @Context
Аннотация @Context используется для внедрения информации в класс поле, свойство компонента или параметр метода.

* Используется для вставки 12 объектов (см. ниже).
* Используется JAX-RS для обозначения того, что требуемый объект, связанный с запросом, будет внедрен в параметр метода.
* Позволяет получать доступ к различным объектам, таким как HttpHeaders, UriInfo, SecurityContext и др., без необходимости объявлять их в классе ресурса.
* Работает похожим образом, как @Autowired из Spring или @Inject из Java EE.
* Может применяться к полям, конструкторам или методам класса ресурса.
* Можно указывать на поле класса, параметр метода или свойство компонента.
* Является частью спецификации JAX-RS, а не языка Java.

Назначение классов 12 объектов:

* Application - представляет экземпляр приложения JAX-RS, который содержит конфигурацию и регистрацию компонентов.
* HttpHeaders - представляет заголовки HTTP-запроса.
* Request - представляет HTTP-запрос (информация о методе, URI и сущности запроса, выполнение условной обработки запроса с помощью методов evaluatePreconditions).
* SecurityContext - представляет контекст безопасности HTTP-запроса (информация о пользователе, его роли и схеме аутентификации, проверка разрешений на доступ к ресурсам).
* UriInfo - представляет информацию о URI HTTP-запроса (информация о базовом URI, пути, параметрах и др.).
* Configuration - представляет конфигурацию приложения или ресурса JAX-RS (информация о свойствах, классах и экземплярах компонентов, зарегистрированных в конфигурации).
* ResourceContext - представляет контекст ресурса JAX-RS (информация об экземплярах ресурсов или подресурсов с помощью методов getResource или initResource).
* Providers - представляет коллекцию провайдеров JAX-RS, которые могут быть использованы для преобразования между Java и HTTP. (информация об экземплярах провайдеров с помощью методов getExceptionMapper, getMessageBodyReader или getMessageBodyWriter).
* И другие ...

=== Аннотация @Bean
Аннотация @Bean - это аннотация уровня метода. Данную аннотацию можно использовать только в классе @Configuration или @Component.

Чтобы объявить бин, можно аннотировать метод с помощью @Bean. Этот метод используется для регистрации определения бина в ApplicationContext того типа, который задан в качестве возвращаемого значения метода. По умолчанию имя бина совпадает с именем метода

TIP: Spring ApplicationContext — это место, где Spring хранит экземпляры бинов, которые он определил для автоматического управления и распределения.

==== Область видимости бинов
Можно задать определенную область доступности бина, с помощью аннотации @Scope. По умолчанию используется область доступности на уровне singleton.

=== Аннотации MVC

* @Controller - указывает, что класс является контроллером, который может обрабатывать HTTP-запросы. Эта аннотация позволяет контейнеру Spring автоматически сканировать и регистрировать классы-контроллеры.

* @RequestMapping - указывает, что метод контроллера соответствует определенному URL-пути или HTTP-методу. Эта аннотация позволяет маппить запросы пользователя на методы контроллера.

* @RequestParam - указывает, что параметр метода контроллера соответствует определенному параметру запроса. Эта аннотация позволяет получать значения параметров запроса в методе контроллера.

* @ModelAttribute - указывает, что параметр метода контроллера соответствует определенной модели данных. Эта аннотация позволяет связывать данные из запроса с объектами модели.

* @ResponseBody - указывает, что возвращаемое значение метода контроллера является телом ответа. Эта аннотация позволяет отправлять данные в формате JSON, XML или другом в ответ на запрос.

* @PathVariable - указывает, что параметр метода контроллера соответствует определенной части URL-пути. Эта аннотация позволяет получать значения переменных пути в методе контроллера.

* @Autowired - указывает, что поле класса или параметр конструктора требует автоматического внедрения зависимости от другого бина (объекта, управляемого контейнером Spring). Эта аннотация позволяет избежать явного создания и связывания объектов в коде.