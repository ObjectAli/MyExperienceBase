= Gradle

Gradle Build Tool — это инструмент автоматизации сборки с открытым исходным кодом и декларативным языком сборки.

TIP: На официальном сайте Gradle есть собственные курсы и уроки.

== Преимущества Gradle
* Это широко используемый и проверенный инструмент с активным сообществом и сильной поддержкой разработчиков.
* Это самая популярная система сборки для JVM и система по умолчанию для многоплатформенных проектов Android и Kotlin. Он имеет богатую экосистему плагинов сообщества.
* Gradle может автоматизировать широкий спектр сценариев сборки программного обеспечения, используя встроенные функции, сторонние плагины или собственную логику сборки.
* Gradle быстр, масштабируем и позволяет создавать проекты любого размера и сложности.
* Gradle является надёжным инструментом, пользуясь преимуществами таких оптимизаций, как инкрементные сборки, кэширование сборок и параллельное выполнение.
* Возможность использовать задачи Ant-инструмента.
* Не заточен под определённый язык - универсален.

== Жизненный цикл сборки
Gradle является примером программирования на основе зависимостей: вы определяете задачи и зависимости между задачами, а Gradle гарантирует, что эти задачи выполняются в порядке их зависимостей. Скрипты сборки и подключаемые модули настраивают этот граф зависимостей.

=== Графики задач
Некоторые средства сборки собирают граф задач по мере выполнения задач. Gradle строит граф задач перед выполнением любой задачи. Избегая конфигурации, Gradle пропускает настройку для задач, которые не являются частью текущей сборки. В рамках каждого проекта задачи образуют направленный ациклический граф (DAG).

== Этапы сборки
Сборка Gradle состоит из трех отдельных этапов. Gradle запускает эти этапы по порядку: сначала инициализация, затем настройка и, наконец, выполнение.

=== Инициализация
* Обнаруживает файл настроек.
* Оценивает файл параметров, чтобы определить, какие проекты и включенные сборки участвуют в сборке.
* Создает экземпляр Project для каждого проекта.

=== Конфигурация
* Оценивает сценарии сборки каждого проекта, участвующего в сборке.
* Создает граф задач для запрошенных задач.

=== Исполнение
* Планирует и выполняет каждую из выбранных задач в порядке их зависимостей.

== Каталоги и файлы, используемые Gradle
Gradle использует два основных каталога для выполнения и управления своей работой: домашний каталог пользователя Gradle и корневой каталог Project.

=== Домашний каталог пользователя Gradle
Домашняя каталог пользователя Gradle (по умолчанию) используется для хранения глобальных свойств конфигурации и сценариев инициализации, а также кэшей и файлов журналов.

=== Корневой каталог проекта
Корневой каталог проекта содержит все исходные файлы, которые являются частью проекта. Кроме того, он содержит файлы и каталоги, созданные Gradle. В то время как первые обычно возвращаются в систему управления версиями, вторые являются временными файлами, используемыми Gradle для поддержки таких функций, как инкрементные сборки.

==== Очистка кэша проекта
Начиная с версии 4.10, Gradle автоматически очищает каталог кэша для конкретного проекта. После сборки проекта каталоги кэша для конкретной версии периодически проверяются (не более чем каждые 24 часа) на предмет их использования. Они удаляются, если не использовались в течение 7 дней.


== Принцип работы
=== Задачи
Работа, которую Gradle может выполнять над проектом, определяется одной или несколькими задачами. Задача представляет собой некоторую атомарную часть работы, которую выполняет сборка. Это может быть компиляция некоторых классов, создание JAR-файла, создание Javadoc или публикация некоторых архивов в репозитории.

=== Манипулирование существующими задачами
После регистрации задач к ним можно получить доступ через API. Например, вы можете использовать это для динамического добавления зависимостей к задаче во время выполнения. Ant не допускает ничего подобного.


=== О внутренностях файла build.gradle

==== Терминология Gradle включает в себя три элемента:
* Repository (repositories {}) — где искать модули, которые вы объявляете зависимостями (Например, mavenCentral()- из репозитория Maven Central)
* Configuration —  коллекция зависимостей, сгруппированных для определенной цели, такой как компиляция или запуск модуля — более гибкая форма областей Maven implementation
* Module coordinate — идентификатор зависимости, обычно в виде '<group>:<module>:<version>' (или '<groupId>:<artifactId>:<version>' в терминологии Maven)org.hibernate:hibernate-core-3.6.7.Final

===== Конфигурация
Конфигурация - механизм описания области видимости(доступа) зависимостей

Функции:

* Разделение объявления зависимостей по функциям (тесты, логика проекта)
* Возможность применения наследования (конфигурации могут наследоваться). Метод extendsFrom
* Разграничение конфигураций по ролям (Объявление зависимостей, описание потребителя зависимостей, описание производителя зависимостей)
* Формирование пользовательских решений в конфигурации(задач)
* Управления версиями зависимостей
* Описание отношений между модульными блоками
* Документирование зависимостей

====== Область доступа конфигураций (scope)
* implementation — указывает, что зависимость или артефакт требуется ТОЛЬКО для КОМПИЛЯЦИИ и ВЫПОЛНЕНИЯ compile, но не для его потребителей.
* api - указывает, что зависимость или артефакт требуется НЕ ТОЛЬКО для КОМПИЛЯЦИИ и ВЫПОЛНЕНИЯ модуля, но и ДЛЯ его ПОТРЕБИТЕЛЕЙ.
* compileOnly —  указывает, что зависимость или артефакт требуется  ТОЛЬКО для КОМПИЛЯЦИИ рабочего кода, но НЕ ДЛЯ его ВЫПОЛНЕНИЯ или его ПОТРЕБИТЕЛЕЙ. Не должны быть частью пути к классам среды выполнения.
* compileClasspath (Расширяет compileOnly, implementation) - Компилируемый путь к классам, используемый при компиляции исходного кода. Используется по задаче.
* runtimeOnly — используется только для ВЫПОЛНЕНИЯ, но НЕ для КОМПИЛЯЦИИ или его ПОТРЕБИТЕЛЕЙ.
* runtimeClasspath (НАСЛЕДУЕТ runtimeOnly, implementation) - Путь к классам среды выполнения содержит элементы реализации, а также элементы только среды выполнения. Она ИГНОРИРУЕТ изменения, которые не влияют на API классов в classpath (такие, как изменения пути к jar-файлам, порядка элементов в jar-файлах, ресурсов и манифестов jar-файлов, приватных элементов классов, кода и отладочной информации).
* annotationProcessor - Обработчики аннотаций, используемые при компиляции.
* testCompileOnly — эквивалент compileOnly для ТЕСТОВОГО КОДА
* testImplementation — эквивалент implementation для ТЕСТОВОГО КОДА
* testRuntimeOnly — эквивалент runtimeOnly для ТЕСТОВОГО КОДА

Комбинации функций предоставлений зав-тей на этапах компиляции, поставки, выполнения.

==== Разбор блоков
=====  Использование подключаемого модуля Java
[source, groovy]
----
plugins {
    id 'java'
}
----

Подключаемый модуль Java добавляет в проект ряд задач:

* processResources (ресурсы процесса) - Копирует производственные ресурсы в каталог производственных ресурсов.
* classes (зависит от compileJava, processResources) - Это совокупная задача, которая просто зависит от других задач. Другие плагины могут прикрепить к нему дополнительные задачи компиляции.
* processTestResources - Копирует тестовые ресурсы в каталог тестовых ресурсов.
* testClasses (зависит от compileTestJava, processTestResources) - Это совокупная задача, которая просто зависит от других задач. Другие плагины могут присоединять к нему дополнительные задачи компиляции тестов.
* jar - Собирает рабочий JAR-файл на основе классов и ресурсов, присоединенных к набору исходного кода.
* javadoc - Создает документацию по API для производственного исходного кода Java с помощью Javadoc.
* test - Запускает модульные тесты с помощью JUnit или TestNG.
* clean - Удаляет каталог сборки проекта.
* cleanTaskName - Удаляет файлы, созданные указанной задачей. Например, удалит JAR-файл, созданный задачей, и удалит результаты теста, созданные задачей.


== Главные отличия Gradle от Maven
* Gradle - декларативный - Groovy
* Maven - императивный - json
* Gradle использует Groovy или Kotlin в качестве языка сценариев сборки, а Maven использует XML. Это делает Gradle более выразительным и гибким, но также требует большего знания этих языков.
* Gradle поддерживает инкрементальную сборку, которая означает, что он выполняет только те задачи, которые необходимы для достижения желаемого результата. Maven же всегда выполняет все задачи в определенном порядке.
* Gradle позволяет выполнять задачи параллельно на одном или нескольких компьютерах, а также использовать Gradle Build Cache для кэширования результатов задач на удаленном сервере. Maven не имеет таких возможностей
* Gradle имеет более гибкую модель жизненного цикла сборки, чем Maven. Вы можете определять свои собственные фазы и цели сборки, а также использовать предопределенные плагины для разных типов проектов. Maven же имеет фиксированный набор фаз и целей сборки, который зависит от типа проекта.
* Gradle поддерживает больше языков и платформ, чем Maven. Вы можете использовать Gradle для сборки проектов на Java, Kotlin, Android, C++, Swift и других. Maven же ориентирован в основном на Java и его экосистему.
* Gradle имеет более дружественный к пользователю интерфейс командной строки, чем Maven. Вы можете использовать различные опции и флаги для управления процессом сборки, а также получать подробную информацию о ходе выполнения задач. Maven же имеет более ограниченный набор опций и флагов, а также менее информативный вывод.

== Инструмент BuildScan
Разработчики Gradle, предоставляют бесплатную услугу Build Scan, которая предоставляет обширную информацию и аналитические сведения о ваших сборках. Вы можете выполнить сканирования, чтобы выявить проблемы, или поделиться ими для помощи в отладке.

Чтобы зарегистрировать задачу, достаточно использовать команду tasks.register()

[source, groovy]
----
tasks.register('upper') {
    doLast {
        String someString = 'mY_nAmE'
        println "Original: $someString"
        println "Upper case: ${someString.toUpperCase()}"
    }
}
----