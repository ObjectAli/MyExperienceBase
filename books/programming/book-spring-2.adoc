= Spring в действии. Глава 2. Разработка ВЕБ-приложений

== Предметная область
Предметная область - это идеи и концепции, влияющие на понимание приложения (с.56).


=== надо обработать
Ключевые тезисы Главы 2: «Разработка веб-приложений»
1. Главная цель главы
Показать, как использовать Spring для создания контроллеров — компонентов, которые обрабатывают веб-запросы. Вы научитесь создавать простые контроллеры, обрабатывать ввод данных от пользователя и проверять их.

2. Архитектурный паттерн: MVC (Model-View-Controller)
Spring следует этому классическому паттерну, который разделяет обязанности в приложении:

Контроллер (Controller): Обрабатывает запросы, управляет потоком данных. Это ваш Java-класс с аннотациями.

Модель (Model): Содержит данные, которые должны быть отображены в представлении. По сути, это атрибуты, которые контроллер передает в представление.

Представление (View): Отвечает за визуализацию (отображение) данных пользователю. Обычно это HTML-шаблон (Thymeleaf).

3. Аннотации для маппинга запросов (Request Mapping)
Spring предоставляет несколько аннотаций для привязки HTTP-запросов к методам контроллера. Это основа веб-слоя.

@GetMapping: Обрабатывает HTTP GET запросы. Используется для получения данных (например, загрузка страницы формы).

@PostMapping: Обрабатывает HTTP POST запросы. Используется для отправки данных (например, отправка заполненной формы).

@RequestMapping: Более общая аннотация, которая может работать с любым HTTP-методом (например, @RequestMapping(method=RequestMethod.GET)). Но @GetMapping и @PostMapping — это его специализированные и более удобные версии.

4. Передача данных в представление (Модель)
Чтобы отобразить динамические данные в HTML-шаблоне, контроллер должен передать их в представление. Для этого используется объект Model.

Вы добавляете объект Model в параметры метода контроллера.

Добавляете атрибуты в модель с помощью метода addAttribute().

Thymeleaf (или другой шаблонизатор) затем может получить доступ к этим атрибутам.

Пример:

java
@GetMapping("/design")
public String showDesignForm(Model model) {
model.addAttribute("ingredients", ingredientRepository.findAll());
return "design";
}
5. Обработка входных данных (Form Handling)
Ключевой сценарий: пользователь заполняет форму и нажимает «Отправить». Контроллер должен:

Получить данные из формы.

Проверить их.

Сохранить или обработать.

Для этого метод контроллера, помеченный @PostMapping, принимает объект, который представляет собой данные формы. Spring автоматически связывает (binds) поля формы со свойствами этого объекта.

Пример:
У вас есть класс Taco. В форме есть поля name и ingredients. Spring создаст объект Taco и заполнит его свойства значениями из полей формы.

java
@PostMapping
public String processTaco(Taco taco) {
// Spring автоматически создаст объект Taco из данных формы
tacoRepository.save(taco); // Сохраняем его
return "redirect:/orders/current"; // Перенаправляем пользователя
}
6. Валидация данных (Validation)
Очень важно проверять введенные пользователем данные. Spring легко интегрируется с Java Bean Validation API.

Аннотации валидации: Вы помечаете поля вашего класса аннотациями, например @NotBlank, @Size, @Digits.

@Valid: Вы добавляете эту аннотацию к параметру метода в контроллере, чтобы указать, что объект нужно проверить.

Errors / BindingResult: Если при валидации есть ошибки, они попадают в этот объект. Вы можете проверить его в методе контроллера.

Пример:

java
@PostMapping
public String processTaco(@Valid Taco taco, Errors errors) {
if (errors.hasErrors()) {
return "design"; // Возвращаем обратно на форму, если есть ошибки
}
// ... логика сохранения
}
7. Перенаправление (Redirect)
После успешной обработки POST-запроса лучшей практикой является выполнение перенаправления (redirect). Это предотвращает повторную отправку формы при обновлении страницы пользователем (избегает проблемы «double submission»).

Используется шаблон "redirect:<URL>".

8. Аннотация @SessionAttributes
Используется для хранения объекта в сессии на протяжении нескольких запросов. Это полезно для многошаговых форм, где данные из предыдущих шагов должны быть доступны на следующих (например, заказ тако, а затем ввод данных о доставке).

Объявляется на уровне класса контроллера: @SessionAttributes("order")

Указывает, что атрибут модели с именем "order" должен поддерживаться на уровне сессии.

Ключевой вывод второй главы:
Вы переходите от простых статических страниц к динамическим, интерактивным веб-формам. Вы понимаете полный цикл обработки запроса:

GET-запрос -> Контроллер загружает пустую форму и передает ее в представление.

Пользователь заполняет форму -> POST-запрос.

Контроллер принимает данные, валидирует их.

Если ошибки -> возвращает форму с сообщениями.

Если все OK -> сохраняет данные и делает перенаправление на другую страницу.

Это основа практически любого веб-приложения, и Spring Boot делает этот процесс удивительно простым и лаконичным.