= Базовые знания Java

== Метод - группа команд, с заданным именем.

== Классы
Класс - это шаблон для объекта. Все классы в Java по умолчанию унаследованы от класса Object.

== Импорт классов
В Java полному имени класса соответствует конструкция вида [имя пакета + короткое имя класса]. Имя пакета необходимо, чтобы понимать к какому файлу идёт обращение.
Чтобы в коде не описывать полное имя класса, разрешено использовать короткое имя класса, при условии import-а пакета.
Например:
Полное имя класса com.java.Application.java, где com.java - имя пакета, а Application.java - короткое имя класса.

== Загрузка классов
При загрузке классов в память создаются 3 специальных "объекта":

* Код методов класса, скомпилированный в машинный код
* Класс: статические методы и переменные
* Специальный объект типа java.lang.Class, в котором хранится информация о загруженном классе, его имена методов, имена и типы полей и т.п. Хранит информацию о загруженном классе

== Класс-обёртки
Классы-обёртки - классы, которые оборачивают примитивные типы в классы.
Пример: int - Integer

=== Сравнение классов-обёрток
IMPORTANT: При сравнении классов-обёрток через оператор "==" на самом деле сравниваются их ссылки. Для сравнения самого значения нужно использовать метод "equals()"

IMPORTANT: Значение классов обёрток может закешироваться, (Например у Integer для значений от -128 до 127 включительно объекты кешируются).

== Методы

=== Области видимости
Всего 3 области видимости:

* public - из любого места программы
* private - доступ только внутри класса
* protected - доступ разрешен внутри класса и из классов-наследников

=== Базовые методы

==== Метод equals()
Метод equals() сравнивает ссылки на объекты. Обычно переопределяется, в котором описывают сравнение объектов последовательно по каждому атрибуту.
Таким образом получится детальное сравнение объектов

==== Метод hashCode()
Метод hashCode() необходим для быстрой проверки (выполнить первичную проверку, дабы убедиться в необходимости сложной проверки).
Если вызвать метод hashCode() у объекта, результатом будет число, которое обладает следующими свойствами:

* У одинаковых объектов всегда одинаковые hash-code
* У разных объектов могут быть одинаковые hash-code, а могут быть разные
* Если у объектов разные hash-code, объекты точно разные

Итог: Сначала у двух объектов вычисляются hash-code. Если эти hash-code разные, то объекты точно разные, и сравнивать их дальше не нужно. А вот если hash-code одинаковые, придется все же сравнивать объекты с помощью equals.

==== Метод finalize()
Метод finalize() вызывается сборщиком мусора перед удалением объекта, НО не всегда:)
Java-машина сама определяет, вызывать метод finalize() в каждом конкретном случае или нет.


=== Перегрузка методов
Перегрузка методов - это механизм, когда у методов одинаковое наименование и тип возвращаемого результата, НО разный набор входных параметров.
У методов должны быть уникальные сигнатуры (Сигнатура = имя метода + набор входных параметров и их типов).
Перегрузку методов ещё называют "Параметрический полиморфизм"

=== Обработка параметров
В Java обработка входных параметров происходит по-разному для примитивов (int, char) и объектов.
При передаче методу во входной параметр примитива НА САМОМ ДЕЛЕ передаётся его копия. Поэтому изменение входного параметра (копии) не отобразится на изменении самого примитива.
При передаче методу во входной параметр объекта НА САМОМ ДЕЛЕ передаётся ссылка на объект. Поэтому при изменении входного параметра в виде объекта, происходит обращение к той самой области памяти, где хранится сам объект.

== Типы данных
=== short
Разные типы данных нужны для разных целей. Но для чего, например, short(число от -32 до +32), когда есть int(число от -2,147,483,648 до +2,147,483,647)?
Допустим, у вас ситуация, когда заранее известно, что значения с которыми вы работаете не превышает 30 тысяч, и таких значений миллионы.

Пример: Вы пишете приложение, которое обрабатывает картинки сверхвысокой четкости: на один цвет приходится 10 бит. А точек у вас в картинке — миллион. И вот тут уже играет роль, используете вы тип int или short.

=== float|double (числа с плавающей точкой)
Числа с плавающей точкой обладают одной интересной особенностью: они позволяют хранить специальное значение, обозначающее бесконечность. Причем может быть положительная бесконечность и отрицательная бесконечность.
Пример: c == Infinity

=== char
На самом деле тип char хранит не символы, а коды символов из кодировки Unicode. Каждому символу соответствует число — числовой код символа.
Тип char — гибридный тип. Его значения можно интерпретировать и как числа (их можно складывать и умножать), и как символы. Так было сделано потому, что хоть символы и имеют визуальное представление, для компьютера они в первую очередь просто числа. И работать с ними как с числами гораздо удобнее.

=== String
String, условно, - это массив символов (хотя на самом деле в виду подкапотных оптимизаций является массивом БАЙТОВ).
Все строки, которые были заданы в коде в виде литералов, во время работы программы хранятся в памяти в так называемом StringPool. StringPool — это специальный массив для хранения строк. Цель его создания — оптимизация хранения строк:
Когда код вашего класса загружается Java-машиной, все строковые литералы добавляются в StringPool, если их там еще нет. Если уже есть, просто используется ссылка на строку из StringPool.

==== StringBuilder
StringBuilder - это как String, только его можно менять, в то время как при изменении объекта типа String, каждый раз создаётся новая строка.

==== StringBuffer
StringBuffer - аналог StringBuilder, только его методы имеют модификатор synchronized. А это значит, что к объекту StringBuffer можно одновременно обращаться из нескольких потоков.

==== Разница между StringBuilder и StringBuffer
StringBuffer можно одновременно обращаться из нескольких потоков. Зато он работает гораздо медленнее, чем StringBuilder. StringBuffer используется при многопоточном подходе.


== Расшифровка вывода toString()
I@37afeb11, где
I - тип данных (int)
37afeb11 - адрес ячейки памяти, в которой хранится переменная

== Массивы
=== Сравнение массивов
Метод equals() у массивов работает как оператор "==" сравнивает не содержимое массивов, а ссылки. Для сравнения массивов есть Arrays.equals().

=== Заполнение массивов
Для заполнения массива одинаковыми элементами есть метод Arrays.fill(<Имя массива>, <Значение>).

=== Сортировка массивов
Для сортировки массивов существует метод Arrays.sort() (по принципу самого быстрого алгоритма сортировки QuickSort: N*Log(N)).

== Статических методы и переменные
Статические методы и переменные, в отличие от обычных, появляются как только класс загружается в память. Статический объект класса существует даже если не был создан ни один обычный объект класса.
Для их использования не требуется инициализация объекта. Статический объект всегда существует в единственном экземпляре.

== Побитовое сравнение
Отличие && от & иои || от | в том, что в случае с одним символом сравнение происходит побитово.
В случае двойного символа логического сравнения (например &&), сравнение происходит слева-напрово поочерёдно. Поэтому как только будет вычеслено первое условие, не удовлетворяющее заданном, следующие вычисляться не будут.
В случае одного символа логического сравнения (например &), в любом случае будут вычислены все выражения.

== Паузы
Для реализации режима паузы существует метод Thread.sleep(в мс.), НО
Длина паузы = длительность одного витка цикла — время выполнения действия.
Например:
Чтобы действие выполнялось 5 раз в секунду, нужно чтобы время выполнения действия + пауза были равны 200 мс. Тогда оно действительно будет выполняться 5 раз в секунду. В нашем случае действие выполняется 100 мс, значит на паузу остается еще 100 мс

== Литералы
Данные, вписанные прямо в код программы, называют литералами.
Литералы могут использовать символы:

* '_' - для разделения тысячных. Пример: long a = 3_000_000_000L;
* '.' - для вещественных чисел. Если в коде есть число, и у числа есть точка, то это число - литерал с плавающей точкой. Пример: double a = 100.0 (или .1).
* 'E' - для вещественных чисел. Обозначает 10 в степени. Например: 1.23E3 (литерал) | 1.23 * 10^3 (мат-ая запись) | 1230.0 (итоговое значение).
* '<1 символ>' - для символов. Символьный литерал может и ОБЯЗАТЕЛЬНО ДОЛЖЕН содержать только 1 символ (кроме символов кодировки Unicode-начинаются с \u ). Примеры: 'A', '@', '\u1f3a'.
* '0<что-то там>' - любой целочисленный литерал, начинающийся с 0, считается Java восьмеричным.
* '0b<что-то там>' - литерал, начинающийся с 0b, считается java двоичным (бинарным).
* '0x<что-то там>' - литерал, начинающийся с 0x, считается java шестнадцатеричным.

== Конструкторы
Если у вашего класса вообще нет ни одного конструктора, компилятор добавит вам в класс конструктор-по-умолчанию – конструктор без параметров и кода, но с модификатором public.
Однако, если в вашем классе есть хотя бы один конструктор, конструктор-по-умолчанию уже добавляться не будет – вам нужно будет дописать его самостоятельно.
IMPORTANT: При создании объекта переменные класса сначала инициализируются своими значениями, а уже затем выполняется код конструкторов.

IMPORTANT: final переменной можно сразу не присваиваться значение, если сделать присвоение во всех конструкторах.

== Выведение типов Java-компилятором

=== Autoboxing и unboxing
Классы-обёртки НЕИЗМЕНЯЕМЫ (immutable).  Чтобы создать объект типа Integer с новым значением типа int, нужно явно создать новый объект Integer. А получить значение типа int, которое хранится внутри объекта Integer, просто: нужно вызвать метод intValue().
Для того чтобы код был менее громоздкий существует инструменты autoboxing и unboxing.  Автоматическое преобразование int в Integer называется autoboxing (box — коробка, класть в коробку), а обратная операция — Integer к int — unboxing.
Пример 1:
[source, java]
----
Integer a = 10; //на самом деле компилятор видит "Integer a = Integer.valueOf(10)"
----

Пример 2:
[source, java]
----
int b = a; //на самом деле компилятор видит "int b = a.intValue()"
----

=== Выведение типа переменной – var
var описывает тип переменной, который определяется автоматически во время компиляции.
Пример:
[source, java]
----
var i = 10;
----
TIP: Начиная с Java 11

=== Двойные фигурные скобки в массивах
Наполнение массива, с помощью двойных фигурных скобок
Пример:
[source, java]
----
var list = new ArrayList<String>()
{{
   add("Привет");
   add("Как");
   add("Дела");
}};
----

Аналогично:
[source, java]
----
var list = new ArrayList<String>()

list.add("Привет");
list.add("Как");
list.add("Дела");
----

== Дженерики (Generigs)
Дженерики - механизм составления сложных типов параметров (используя конструкцию вида 'ОсновнойТип<ТипПараметр>').
Например: ArrayList<Iteger>
При использовании дженериков, компилятор добавляет оператор привидения типа.
У классов может быть не один тип параметр, а несколько (ОсновнойТип<ТипПараметр1, ТипПараметр2, ТипПараметр3>).


Пример кода:
[source, java]
----
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(1);
----

Что сделает компилятор:
[source, java]
----
ArrayList list = new ArrayList();
list.add((Integer) 1);
----

== Iterator
Итератор — это специальный объект у коллекции, который помогает обойти все элементы коллекции и не повторяться.
Пример:
[source, java]
----
List<String> list = new ArrayList<String>();

Iterator<String> it = list.iterator();
while (it.hasNext())
{
   String str = it.next();
   System.out.println(str);
}
----

== for-each
Оператор for-each является "синтаксическим сахаром", но стоит понимать, что компилятор его видит как "Цикл с итератором" (Iterator)

Чем for-each хуже чем for:

* Нельзя пройти от конца в начало (от обратного)
* Не подходит при внесении изменений в массив
* При поиске индекса искомого элемента, лучше воспользоваться обычным циклом for.

TIP: Важно! Нельзя удалять элементы коллекции внутри for-each. Нужно явно использовать для таких целей Iterator.

== switch-case
Оператор switch-case всегда можно заменить оператором if-else.
В качестве значений для case внутри оператора switch можно использовать литералы таких типов:

* целые типы: byte, short, int
* тип char
* тип String
* значения любого enum-типа

=== try-with-resources
!Начиная с 7-й версии Java
Оператор "try-with-resources" аналог оператора try-catch-finally для работы с внешними файлами.

TIP: Внешние файлы - это файлы, созданные вне Java-машины.

Назначение: при использовании данного оператор, закрытие использования внешнего файла происходит автоматически

Пример с оператором "try-catch-finally"
[source, java]
----
FileOutputStream output = null; //так как при инициализации может произойти ошибка, инициализация происходит в самом блоке "try"

try
{
   output = new FileOutputStream(path);
   output.write(1);
}
finally
{
   if (output != null)  //обращение к файлу имеет смысл закрывать, только если инициализация произошла успешно
   output.close();
}
----


Пример с оператором "try-with-resources"
[source, java]
----
try(FileOutputStream output = new FileOutputStream(path)) //инициализация объекта происходит сразу, так как за закрытие обращения к внешнему файлу отвечает сам оператор
{
   output.write(1);
}
----

WARNING: В качестве ресурсов в try-with-resources можно передавать только объекты классов унаследованных от AutoCloseable (в нём описан контракт метода close())


== Лямбда-выражения
Лямбда-выражение можно записать там, где используется тип-интерфейс с одним-единственным методом.