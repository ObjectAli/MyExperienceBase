= Базовые знания Java

== Метод - группа команд, с заданным именем.

== Испорт классов
В Java полному именни класса соответствует конструкция вида [имя пакета + короткое имя класса]. Имя пакета необходимо, чтобы понимать к какому файлу идёт обращение.
Чтобы в коде не описывать полное имя класса, разрешено использовать короткое имя класса, при условии import-а пакета.
Например:
Полное имя класса com.java.Application.java, где com.java - имя пакета, а Application.java - короткое имя класса.

== Загрузка классов
При загрузке классов в память создаются 3 специальных "объекта":

* Код методов класса, скомпилированный в машинный код
* Класс: статические методы и переменные
* Специальный объект типа java.lang.Class, в котором хранится информация о загруженном классе, его имена методов, имена и типы полей и т.п. Хранит информацию о загруженном классе

== Типы данных
=== short
Разные типы данных нужны для разных целей. Но для чего, например, short(число от -32 до +32), когда есть int(число от -2,147,483,648 до +2,147,483,647)?
Допустим, у вас ситуация, когда заранее известно, что значения с которыми вы работаете не превышает 30 тысяч, и таких значений миллионы.

Пример: Вы пишете приложение, которое обрабатывает картинки сверхвысокой четкости: на один цвет приходится 10 бит. А точек у вас в картинке — миллион. И вот тут уже играет роль, используете вы тип int или short.

=== float|double (числа с плавающей точкой)
Числа с плавающей точкой обладают одной интересной особенностью: они позволяют хранить специальное значение, обозначающее бесконечность. Причем может быть положительная бесконечность и отрицательная бесконечность.
Пример: c == Infinity

=== char
На самом деле тип char хранит не символы, а коды символов из кодировки Unicode. Каждому символу соответствует число — числовой код символа.
Тип char — гибридный тип. Его значения можно интерпретировать и как числа (их можно складывать и умножать), и как символы. Так было сделано потому, что хоть символы и имеют визуальное представление, для компьютера они в первую очередь просто числа. И работать с ними как с числами гораздо удобнее.

=== String
String, условно, - это массив символов (хотя на самом деле в виду подкапотных оптимизаций является массивом БАЙТОВ).
Все строки, которые были заданы в коде в виде литералов, во время работы программы хранятся в памяти в так называемом StringPool. StringPool — это специальный массив для хранения строк. Цель его создания — оптимизация хранения строк:
Когда код вашего класса загружается Java-машиной, все строковые литералы добавляются в StringPool, если их там еще нет. Если уже есть, просто используется ссылка на строку из StringPool.

==== StringBuilder
StringBuilder - это как String, только его можно менять, в то время как при изменении объекта типа String, каждый раз создаётся новая строка.

==== StringBuffer
StringBuffer - аналог StringBuilder, только его методы имеют модификатор synchronized. А это значит, что к объекту StringBuffer можно одновременно обращаться из нескольких потоков.

==== Разница между StringBuilder и StringBuffer
StringBuffer можно одновременно обращаться из нескольких потоков. Зато он работает гораздо медленнее, чем StringBuilder. StringBuffer используется при многопоточном подходе.



== Расшифровка вывода toString()
I@37afeb11, где
I - тип данных (int)
37afeb11 - адрес ячейки памяти, в которой хранится переменная

== Массивы
=== Сравнение массивов
Метод equals() у массивов работает как оператор "==" сравнивает не содержимое массивов, а ссылки. Для сравнения массивов есть Arrays.equals().

=== Заполнение массивов
Для заполнения массива одинаковыми элементами есть метод Arrays.fill(<Имя массива>, <Значение>).

=== Сортировка массивов
Для сортировки массивов существует метод Arrays.sort() (по принципу самого быстрого алгоритма сортировки QuickSort: N*Log(N)).

== Статических методы и переменные
Статические методы и переменные, в отличие от обычных, появляются как только класс загружается в память. Статический объект класса существует даже если не был создан ни один обычный объект класса.
Для их использования не требуется инициализация объекта. Статический объект всегда существует в единственном экземпляре.

== Удобные классы*
Классы, с готовой реализацией
Math - математические формулы(синусы, логарифмы, квадтра и т.д.)
TimeUnit - работа с временем (задержки и т.д.)
StringTokenizer - специальный класс, вся работа которого — разделять строку на подстроки.

== Побитовое сравнение
Отличие && от & иои || от | в том, что в случае с одним символом сравнение происходит побитово.
В случае двойного символа логического сравнения (например &&), сравнение происходит слева-напрово поочерёдно. Поэтому как только будет вычеслено первое условие, не удовлетворяющее заданном, следующие вычисляться не будут.
В случае одного символа логического сравнения (например &&), в любом случае будут вычислены все выражения.

== Паузы
Для реализации режима паузы существует метод Thread.sleep(в мс.), НО
Длина паузы = длительность одного витка цикла — время выполнения действия.
Например:
Чтобы действие выполнялось 5 раз в секунду, нужно чтобы время выполнения действия + пауза равнялись 200 мс. Тогда оно действительно будет выполняться 5 раз в секунду. В нашем случае действие выполняется 100 мс, значит на паузу остается еще 100 мс

== Литералы
Данные, вписанные прямо в код программы, называют литералами.
Литералы могут использовать символы:

* '_' - для разделения тысячных. Пример: long a = 3_000_000_000L;
* '.' - для вещественных чисел. Если в коде есть число, и у числа есть точка, то это число - литерал с плавающей точкой. Пример: double a = 100.0 (или .1).
* 'E' - для вещественных числе. Обзначает 10 в степени. Например: 1.23E3 (литерал) | 1.23 * 10^3 (мат-ая запись) | 1230.0 (итоговое значение).
* '<1 символ>' - для символов. Символьный литерал может и ОБЯЗАТЕЛЬНО ДОЛЖЕН содержать только 1 символ (кроме символов кодировки Unicode-начинаются с \u ). Примеры: 'A', '@', '\u1f3a'.
* '0<что-то там>' - любой целочисленный литерал, начинающийся с 0, считается Java восьмеричным.
* '0b<что-то там>' - литерал, начинающийся с 0b, считается java двоичным (бинарным).
* '0x<что-то там>' - литерал, начинающийся с 0x, считается java шестнадцатеричным.

11 уровень, 0 лекция